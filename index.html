<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resource Allocation Graph with Add Resource</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .node.process {
            fill: steelblue;
        }
        .node.resource {
            fill: orange;
        }
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 2px;
        }
        .boundary {
            fill: none;
            stroke: black;
            stroke-width: 3px;
        }
        .highlight {
            stroke: green;
            stroke-width: 3px;
        }
    </style>
</head>
<body>
    <div id="rag-container"></div>
    <button onclick="addNode()">Add Process</button>
    <button onclick="addResource()">Add Resource</button>
    <script>
        // Sample data for Resource Allocation Graph
        const nodes = [
            { id: 'P1', type: 'process' },
            { id: 'P2', type: 'process' },
            { id: 'R1', type: 'resource' },
            { id: 'R2', type: 'resource' },
            { id: 'R3', type: 'resource' }
        ];

        const links = [
            { source: 'P1', target: 'R1' },
            { source: 'R1', target: 'P2' },
            { source: 'P2', target: 'R2' },
            { source: 'P1', target: 'R3' }
        ];

        // Set up the SVG canvas dimensions
        const width = 800, height = 600;
        const svg = d3.select("#rag-container")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        // Add a visible boundary
        svg.append("rect")
            .attr("class", "boundary")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", width)
            .attr("height", height);

        let selectedNode = null; // Track the selected node for linking

        // Create a force simulation
        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(150))
            .force("charge", d3.forceManyBody().strength(-200))
            .force("center", d3.forceCenter(width / 2, height / 2));

        // Function to render the graph
        function renderGraph() {
            // Bind link data and draw links
            const link = svg.selectAll(".link")
                .data(links);

            link.enter()
                .append("line")
                .attr("class", "link")
                .merge(link);

            link.exit().remove();

            // Bind node data and draw nodes
            const node = svg.selectAll(".node")
                .data(nodes);

            const nodeEnter = node.enter()
                .append("circle")
                .attr("class", d => `node ${d.type}`)
                .attr("r", 20)
                .on("contextmenu", handleContextMenu) // Add context menu for linking
                .call(d3.drag()
                    .on("start", dragstart)
                    .on("drag", dragged)
                    .on("end", dragend));

            nodeEnter.append("title")
                .text(d => d.id);

            nodeEnter.merge(node);

            node.exit().remove();

            // Restart the simulation with the updated data
            simulation.nodes(nodes);
            simulation.force("link").links(links);
            simulation.alpha(1).restart();
        }

        // Dragging functions for interactivity
        function dragstart(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragend(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Function to handle right-click linking
        function handleContextMenu(event, d) {
            event.preventDefault(); // Prevent the browser's default context menu
            if (!selectedNode) {
                // First node selected
                selectedNode = d;
                d3.selectAll(".node").classed("highlight", node => node === selectedNode);
            } else {
                // Second node selected
                if (selectedNode !== d) {
                    // Check if a valid link can be made
                    if (
                        (selectedNode.type === "process" && d.type === "resource") ||
                        (selectedNode.type === "resource" && d.type === "process")
                    ) {
                        links.push({ source: selectedNode, target: d }); // Use direct references
                        renderGraph();
                    } else {
                        alert("Invalid link: Links must connect processes to resources.");
                    }
                }
                selectedNode = null; // Reset the selection
                d3.selectAll(".node").classed("highlight", false);
            }
        }

        // Function to add a new process node
        function addNode() {
            const newNodeId = `P${nodes.filter(node => node.type === 'process').length + 1}`;
            const newNode = { id: newNodeId, type: 'process' };
            nodes.push(newNode);
            renderGraph();
        }

        // Function to add a new resource node
        function addResource() {
            const newResourceId = `R${nodes.filter(node => node.type === 'resource').length + 1}`;
            const newResource = { id: newResourceId, type: 'resource' };
            nodes.push(newResource);
            renderGraph();
        }

        // Ensure nodes stay within the boundaries
        function applyBoundaryConstraints() {
            nodes.forEach(d => {
                const radius = 20; // Node radius
                if (d.x - radius < 0) d.x = radius; // Left boundary
                if (d.x + radius > width) d.x = width - radius; // Right boundary
                if (d.y - radius < 0) d.y = radius; // Top boundary
                if (d.y + radius > height) d.y = height - radius; // Bottom boundary
            });
        }

        // Initial rendering of the graph
        renderGraph();

        // Update positions of links and nodes after every tick of the simulation
        simulation.on("tick", function () {
            applyBoundaryConstraints();

            svg.selectAll(".link")
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            svg.selectAll(".node")
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);
        });
    </script>
</body>
</html>
